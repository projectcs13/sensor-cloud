{
  "name": "rabbit.js",
  "description": "Easy stream-based messaging using RabbitMQ",
  "version": "0.2.2",
  "homepage": "http://github.com/squaremo/rabbit.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/squaremo/rabbit.js.git"
  },
  "author": {
    "name": "Michael Bridgen",
    "email": "mikeb@squaremobius.net"
  },
  "directories": {
    "lib": "lib"
  },
  "main": "./index",
  "scripts": {
    "test": "./node_modules/mocha/bin/mocha --ui exports test"
  },
  "engines": {
    "node": "0.6 || 0.8 || 0.10"
  },
  "dependencies": {
    "amqp": "0.1.6"
  },
  "devDependencies": {
    "mocha": ""
  },
  "readme": "# Messaging in Node.JS with RabbitMQ\n\n    $ npm install rabbit.js\n\nThis library provides a simple, socket-oriented API* for messaging in\n[node.js](http://nodejs.org/), using\n[RabbitMQ](http://www.rabbitmq.com/) as a backend.\n\n    var context = require('rabbit.js').createContext();\n    context.on('ready', function() {\n      var pub = context.socket('PUB'), sub = context.socket('SUB');\n      sub.pipe(process.stdout);\n      sub.connect('events', function() {\n        pub.connect('events', function() {\n          pub.write(JSON.stringify({welcome: 'rabbit.js'}), 'utf8');\n        });\n      });\n    });\n\n*Yes, rather like ZeroMQ. [See below](#zeromq).\n\n## Uses\n\nThis library is suitable for co-ordinating peers (e.g., Node.JS\nprograms), acting as a gateway to other kinds of network (e.g.,\nrelaying to browsers via SockJS), or simply as a really easy way to\nuse RabbitMQ.\n\n## API\n\nThe entry point is `createContext`, which gives you a factory for\nsockets. You supply it the URL to your RabbitMQ server:\n\n    var context = require('rabbit.js').createContext('amqp://localhost');\n\nA context emits `'error'` with an `Error` object if there's a problem\nwith the underlying connection to the server. This invalidates the\ncontext and all its sockets.\n\nA context may be disconnected from the server with `#close()`. It will\nemit `'close'` once the underlying connection has been terminated.\n\nTo start sending or receiving messages you need to acquire a socket:\n\n    var pub = context.socket('PUB');\n    var sub = context.socket('SUB');\n\nand connect it to something:\n\n    pub.connect('alerts');\n    sub.connect('alerts');\n\nSockets act like (\"old style\")\n[Streams](http://nodejs.org/docs/v0.8.25/api/stream.html); in\nparticular you will get `'data'` events from those that are readable,\nand you can `write()` to those that are writable. If you're expecting\ndata that is encoded strings, you can `setEncoding()` to get strings\ninstead of buffers as data events.\n\n    sub.setEncoding('utf8');\n    sub.on('data', function(note) { console.log(\"Alarum! \" + note); });\n    \n    pub.write(\"Emergency. There's an emergency going on\", 'utf8');\n\nYou can also use pipe to forward messages to or from another stream,\nmaking relaying simple:\n\n    sub.pipe(process.stdout);\n\nA socket may be connected more than once, by calling\n`socket.connect(x)` with different `x`s. What this entails depends on\nthe socket type (see below), but messages to and from different\n`connect()`ions are not distinguished. For example\n\n    var sub2 = context.socket('SUB');\n    sub2.connect('system');\n    sub2.connect('notifications');\n\nHere, the socket `sub2` will receive all messages published to\n`'system'` and all those published to `'notifications'` as well, but\nit is not possible to discriminate between the sources.\n\nSome socket types have options that may be set with\n`#setsockopt`. Presently there's just one option, on PUB and PUSH\nsockets, which is message expiration:\n\n    pub.setsockopt('expiration', 60000)\n\nIn the example, messages written to `pub` will be discarded by the\nserver if they've not been delivered after 60,000\nmilliseconds. Message expiration only works with versions of RabbitMQ\nnewer than 3.0.0.\n\nLastly, a socket may be closed using `#end()`; this will clean up\nresources, and emit `'end'` once it's done so.\n\n### Socket types\n\nThe socket types, passed as an argument to `Context#socket`, determine\nwhether the socket is readable and writable, and what happens to\nmessages written to it. Socket types (but not necessarily sockets\nthemselves) should be used in the pairs described below.\n\nTo make the descriptions a bit easier, we'll say if\n`connect(x)` is called on a socket for some `x`, the socket has a\nconnection to x.\n\n**PUB**lish / **SUB**scribe: every SUB socket connected to <x> gets\neach message sent by a PUB socket connected to <x>; a PUB socket\nsends every message to each of its connections. SUB sockets are\nreadable only, and PUB sockets are writable only.\n\n**PUSH** / **PULL**: a PUSH socket will send each message to a\nsingle connection, using round-robin. A PULL socket will receive a\nshare of the messages sent to each <y> to which it is connected,\ndetermined by round-robin at <y>. PUSH sockets are writable only, and\nPULL sockets are readable only.\n\n**REQ**uest / **REP**ly: a REQ socket sends each message to one of\nits connections, and receives replies in turn; a REP socket receives a\nshare of the messages sent to each <y> to which it is connected, and\nmust send a reply in turn. REQ and REP sockets are both readable and\nwritable.\n\n## Using with servers\n\nA few modules have a socket-server-like abstraction; canonically, the\n`net` module, but also for example SockJS and Socket.IO. These can be\nadapted using something similar to the following.\n\n    var context = new require('rabbit.js').createContext('amqp://localhost');\n    var inServer = net.createServer(function(connection) {\n      var s = context.socket('PUB');\n      s.connect('incoming');\n      connection.pipe(s);\n    });\n    inServer.listen(5000);\n\nThis is a simplistic example; a bare TCP socket won't in general emit\ndata in chunks that are meaningful to applications, even if they are\nwritten that way at the far end. A library such as\n[spb](https://github.com/squaremo/node-spb) can be used encode and\ndecode message streams in byte streams if needed.\n\n## Examples\n\nEach subdirectory of `example` has code demonstrating using\nrabbit.js with other modules. Install the prerequisites for rabbit.js\nfirst:\n\n    rabbit.js$ npm install\n\nNow each example can be run with, e.g.,\n\n    rabbit.js$ cd example/sockjs\n    sockjs$ npm install && npm start\n\nAll of the examples assume there is a [RabbitMQ server\nrunning](http://rabbit.mq/download.html) locally. The SockJS and\nSocket.IO examples both start a website which you can visit at\n`http://localhost:8080`.\n\n## <a name=\"zeromq\"></a>Relation to ZeroMQ\n\nrabbit.js was inspired by the [RabbitMQ/ZeroMQ\nadapter](http://github.com/rabbitmq/rmq-0mq/) I developed with Martin\nSÃºstrik. The rationale for using RabbitMQ in a ZeroMQ-based network is\nlargely transferable to rabbit.js:\n\n * RabbitMQ introduces a degree of monitoring and transparency,\n   especially if one uses the web management app;\n * RabbitMQ can bridge to other protocols (notably AMQP and STOMP);\n * RabbitMQ provides reliable, persistent queues if desired\n\nwith some additional benefits:\n\n * since rabbit.js sockets implement the `Stream` interface, one\n   can easily pipe messages around\n * using RabbitMQ as a backend obviates some configuration management\n   -- just supply all instances the broker URL and you're good to go.\n * there's room in the API for more involved routing and other\n   behaviour since AMQP is, well, more complicated let's say.\n\nHere are some notable differences and similarities to ZeroMQ in\nrabbit.js's API and semantics.\n\nTo start, there's no distinction in rabbit.js between clients and\nservers (`connect` and `bind` in ZeroMQ, following the BSD socket\nAPI), since RabbitMQ is effectively acting as a relaying server for\neveryone to `connect` to. Relatedly, the argument supplied to\n`connect()` is abstract, in the sense that it's just a name rather\nthan a transport-layer address.\n\nRequest and Reply sockets have very similar semantics to those in\nZeroMQ. Requesting sockets must take care not to issue more than\nrequest at a time, or to label requests (and rely on repliers\npreserving the label in replies) such that the answers can be\ncorrelated with the requests. Actually this is much the same as\nZeroMQ; it follows from the possibility of replies coming back out of\norder due to round-robining. Repliers must respond to requests in the\norder that they come in, and respond exactly once to each request.\n\nThere are no DEALER or ROUTER sockets (a.k.a., XREQ and XREQ) in\nrabbit.js. In ZeroMQ these are implemented by prefixing messages with\na reverse path, which then requires encoding and thereby complication\nwhen relaying to other streams or protocols. Instead, rabbit.js notes\nthe reverse path as messages are relayed to a REP socket, and\nreapplies it when the response appears (giving rise to the ordering\nrequirement on repliers).\n\n## Relation to AMQP and STOMP\n\nrabbit.js makes some simplifying assumptions that must be kept in mind\nwhen integrating with other protocols that RabbitMQ supports.\n\nPUB and SUB sockets declare non-durable fanout exchanges named for the\nargument given to `connect`. To send to SUB sockets or receive from\nPUB sockets, publish or bind (or subscribe in the case of STOMP) to\nthe exchange with the same name.\n\nPUSH, PULL, REQ and REP sockets use durable, non-exclusive queues\nnamed for the argument given to `connect`. If you are replying, be\nsure to follow the convention of sending the response to the queue\ngiven in the `'replyTo'` property of the request message.\n\n## What happened to `listen()`?\n\nI removed it. It wasn't entirely wrong, but it did have two failings:\nfirstly, it exposed the socket type and the address to the (end)\nclient, while the client ought not to need know about them; secondly,\nand more fatally, it required a dedicated client connection per\nsocket, which is a problem for e.g., browsers.\n\nThe new API avoids these problems by not requiring any particular\nbehaviour from a client connection -- that is totally up to you (if\nyou even use any client connections). If you need to multiplex on a\nclient connection you can do that by, say, prefixing each message with\na channel name; or, as the Socket.IO example does, combine two simplex\nsockets onto a duplex client connection.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/squaremo/rabbit.js/issues"
  },
  "_id": "rabbit.js@0.2.2",
  "dist": {
    "shasum": "471074091a0a976fc8158b73212ffc63a0853105"
  },
  "_from": "rabbit.js@",
  "_resolved": "https://registry.npmjs.org/rabbit.js/-/rabbit.js-0.2.2.tgz"
}
